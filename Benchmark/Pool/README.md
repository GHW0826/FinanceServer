# Pool   
Pool(풀)” 기법은 **반복적으로 생성/소멸**되는 객체나 자원들을 **미리 일정 개수만큼 확보(생성)** 해놓고, **필요 시 재활용**함으로써 **성능과 자원 사용 효율을 높이는** 기법.   
## 1. Pool의 기본 개념

1. **미리 할당**: 특정 자원(스레드, 메모리 블록, 네트워크 소켓 등)을 사용 시점에 즉석에서 생성하지 않고, **프로그램 초기** 혹은 **필요 최소 시점**에 일정 개수를 “미리” 만들어둡니다.
2. **재활용**: 한 번 사용된 자원은 **반납**되면 다시 풀 내부에서 **재사용** 가능하도록 상태를 초기화해둡니다. 이렇게 하면 **반복적 생성/소멸 비용**을 크게 줄일 수 있습니다.
3. **최대치**: 풀에는 일반적으로 **최소/최대 개수**가 정해져 있습니다. 자원을 요청했을 때 여유분이 있으면 **즉시** 할당, 없으면 대기하거나 새로운 자원을 생성합니다(또는 예외 처리). 

즉, **동일 종류의 객체나 자원을 많이, 자주, 그리고 반복적으로 사용**할 때, 생성 및 소멸(할당/해제) 비용을 줄이고 **성능을 향상**하는 것이 풀의 핵심 아이디어입니다.

1. **비싼 생성/소멸 비용 절감**  
   - 스레드 생성/소멸, DB 커넥션 연결/해제, 소켓 오픈/종료 등은 모두 **시스템 호출**이나 **네트워크** 수준의 작업을 수반하기에 비용이 큽니다.  
   - 반복적으로 자원을 생성/소멸하기보다, 한 번 만들어놓은 자원을 재사용하면 **퍼포먼스(성능)와 효율**이 크게 개선됩니다.

2. **리소스 제한 및 관리**  
   - 예를 들어, DB 연결의 수는 제한적입니다. **무제한으로 만들어서** 동시에 사용할 수 없다면, 풀 안에서 **최대 개수**를 통제하고 효율적으로 스케줄링해야 합니다.  
   - 풀 기법을 통해 필요한 자원들을 잘 관리하여 **한정된 리소스**를 안전하게 공유할 수 있습니다.

3. **대기 시간 감소**  
   - 매번 “연결 → 작업 → 연결 해제”를 하는 대신, 이미 **사용 준비가 된 자원**을 가져와 빠르게 사용할 수 있으므로, 응답 시간이 빨라집니다.



   
## 1. ThreadPool   
여러 개의 스레드를 미리 생성해 두고, 작업(Job)이나 태스크를 스레드 풀에 제출하면 대기 중인 스레드가 작업을 가져가 실행하는 방식.   
매번 스레드를 생성/소멸하는 대신, 일정 개수의 스레드를 재사용하여 스레드 생성/컨텍스트 스위치 오버헤드를 줄인다.   
스레드 관리를 중앙화하고, 작업 단위를 추상화하여 코드 복잡도 감소.   

## 2. DBConnectionPool   
외부 DB(예: MySQL, PostgreSQL)에 연결시 TCP/HTTP 커넥션을 빈번히 열고 닫으면 비용이 큼. 이를 풀로 만들어 재활용.   
연결 설정(핸드셰이크, 인증 등) 비용 절감.   
다수 스레드가 동시에 연결을 요청할 때, 일정 개수를 넘어가면 대기하거나 우선순위를 조정.   
DB 연결 풀(DB Pool) : SQL 쿼리를 자주 날리는 서버에서 유용.   

## 3. SocketPool   
서버에서 클라이언트 소켓을 관리할 때, 새로운 연결이 들어올 때마다 소켓을 새로 생성/소멸하는 대신, 미리 만들어둔 소켓 객체(pool)에서 꺼내 쓰고 반환.

## 4. MemoryPool   
메모리 풀이란, 메모리 할당과 해제를 빈번하게 수행할 때 발생하는 오버헤드를 줄이기 위해, 큰 덩어리(chunks)의 메모리를 미리 할당해 두고,    
필요한 때마다 분할하여 재활용하는 기법입니다.
   
일반적인 new/delete(또는 malloc/free)를 자주 호출하면, 커널/런타임 라이브러리에 의존 → 할당 오버헤드가 증가되고,   
메모리 단편화(fragmentation) 메모리 풀은 미리 큰 덩어리를 잡아두고, 내부적으로 소형 블록을 나누어 효율적으로 관리합니다.   
많은 작은 크기의 메모리를 반복적으로 할당/해제하는 경우 성능과 단편화 문제를 완화.   

## 5. ObjectPool   
특정 타입(T)의 객체를 N개 미리 생성(또는 lazy initialization으로 필요할 때 생성).   
사용(Checkout)시 풀에서 “미사용(Unused) 상태”의 객체를 하나 꺼냄.   
필요 시 객체를 초기화(Reset)하거나, 생성자 비슷한 동작으로 재준비.   
반환(Return)시 작업이 끝난 객체를 풀로 돌려보내 “Unused” 상태로 표시.   
다시 쓸 수 있도록 상태를 정리.   

장점으로는  할당/해제 오버헤드 감소.   
OS/런타임 호출보다 훨씬 빠름.   
단편화 완화 풀 내부에서 block size를 효율적으로 관리 → 외부 단편화 줄임.   
캐시 친화성(Cache Friendly) 비슷한 크기의 객체/메모리가 연속적으로 배치되어 locality 개선.   

단점으로는 메모리 소비 미리 큰 메모리를 잡아두므로 “실제 필요량보다 많이” 잡을 수도 있음.   
구현 복잡도 Free 리스트, Alignment(메모리 정렬), 동시성(lock-free, thread-safe) 고려 등이 필요.   

## 6. JobPool   
명령(Command) 객체나 작업(Job) 구조체를 일정 개수만큼 할당해두고, 큐에 넣어 실행한 뒤 재사용.   
Thread Pool과 유사하지만, “어떤 일을 할지” 정보를 담은 소규모 객체를 모아두는 풀.   
작은 단위의 작업 객체를 매번 new/delete하지 않고 재활용 -> 오버헤드 감소.   
